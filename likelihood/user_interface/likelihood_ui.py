# -*- coding: utf-8 -*-
"""LIKELIHOOD USER INTERFACE

Top level user interface class for running CLOE
"""

from likelihood.auxiliary import yaml_handler
from likelihood.auxiliary import likelihood_yaml_handler as lyh
from likelihood.cobaya_interface import EuclidLikelihood
from likelihood.auxiliary.plotter import Plotter
from likelihood.auxiliary.getdist_routines import triangle_plot_cobaya
from likelihood.auxiliary.logger import log_info
import cobaya.run
from cobaya.model import get_model
from pathlib import Path
import collections.abc


class LikelihoodUI:
    r"""Top level user interface class for running CLOE.

    """

    def __init__(self, user_config_file=None, defaults_config_file=None,
                 user_dict=None):
        r"""Constructor.

        Load the default configuration for running CLOE, then (if provided)
        read the user-defined configuration and merge it into the default
        configuration.

        Parameters
        ----------
        user_config_file: str, optional
           Name of the yaml configuration file containing the user-defined
           parameters that will determine the behavior of CLOE.
           If not provided, the parameters from the default configuration will
           be used.

        defaults_config_file: str, optional
           Name of the yaml configuration file containing the default values
           of the parameters that do not appear in the user_config_file. If
           not provided, the file config_default.yaml in the top level of
           the project will be used.

        user_dict: dict, optional
            User-defined dictionary whose keys have higher priority with
            respect to the corresponding keys of user_config_file and
            defaults_config_file.
        """
        if defaults_config_file is None:
            defaults_dir = 'configs'
            defaults_name = 'config_default.yaml'
            defaults_path = Path(__file__).resolve().parents[2]
            defaults_path = defaults_path.joinpath(defaults_dir)
            defaults_config_file = defaults_path.joinpath(defaults_name)

        needed_keys = ['backend', 'Cobaya']
        self._config_path = defaults_config_file
        self._config =\
            yaml_handler.yaml_read_and_check_dict(self._config_path,
                                                  needed_keys)

        if user_config_file is not None:
            log_info(f'Opening user config file: {user_config_file}')

            user_config = \
                yaml_handler.yaml_read_and_check_dict(user_config_file,
                                                      needed_keys)
            self._config = self._update_config(
                orig_config=self._config,
                update_config=user_config
            )

        if user_dict is not None:
            self._config = self._update_config(
                orig_config=self._config,
                update_config=user_dict
            )

        log_info('Selected configuration:')
        log_info(self._config)

        self._backend = self._get_and_check_backend(self._config)
        log_info(f'Selected backend: {self._backend}')

    def run(self):
        r"""Main method to run CLOE

        Read the backend from the input configuration and call the desired
        backend-specific function.

        Returns
        -------
        run: tuple
           An updated information dictionary, plus the products generated by
           the sampler used.
           At present this is the very same thing that is returned by the run()
           method of Cobaya, because Cobaya is the only implemented backend.
        """

        if self._backend == 'Cobaya':
            return self._run_cobaya()

    def _run_cobaya(self):
        r"""Run CLOE using Cobaya as backend.

        Returns
        -------
        run: tuple
          An updated information dictionary, plus the products generated by the
          sampler used.
          This is the very same thing that is returned by the run() method of
          Cobaya.
        """
        cobaya_dict = self._config['Cobaya']
        likelihood_euclid_dict = cobaya_dict['likelihood']['Euclid']

        lyh.check_likelihood_fields(likelihood_euclid_dict)

        model_path = self._get_model_path_from_cobaya_dict(cobaya_dict)
        log_info(f'Selected model path: {model_path}')

        cobaya_dict = \
            lyh.update_cobaya_dict_from_model_yaml(cobaya_dict, model_path)
        lyh.update_cobaya_dict_with_halofit_version(cobaya_dict)
        log_info('Updated Cobaya info dictionary:')
        log_info(cobaya_dict)

        return cobaya.run(cobaya_dict)

    def plot(self, settings):
        r"""Main method to plot CLOE observables

        Read the backend from the input configuration and call the desired
        plotting routine.

        Parameters
        ----------
        settings: str
           Name of the yaml configuration file for the plotting routines
        """

        if self._backend == 'Cobaya':
            return self._plot_cobaya(settings)

    def _plot_cobaya(self, settings):
        r"""Obtain plots and files of CLOE observables using Cobaya as backend

        Parameters
        ----------
        settings: str
           Name of the yaml configuration file for the plotting routines
        """

        cobaya_dict = self._config['Cobaya']
        model_path = self._get_model_path_from_cobaya_dict(cobaya_dict)
        cobaya_dict = \
            lyh.update_cobaya_dict_from_model_yaml(cobaya_dict, model_path)
        lyh.update_cobaya_dict_with_halofit_version(cobaya_dict)
        model = get_model(cobaya_dict)

        logposterior = model.logposterior({})
        like = EuclidLikelihood()
        like.initialize()
        like.passing_requirements(model, **model.provider.params)
        like.cosmo.update_cosmo_dic(like.cosmo.cosmo_dic['z_win'], 0.05)

        if settings is None:
            plotter = Plotter(like.cosmo.cosmo_dic, like.likefinal.data)
        else:
            settings = yaml_handler.yaml_read(settings)
            plotter = Plotter(like.cosmo.cosmo_dic, like.likefinal.data,
                              settings)

        plotter.output_Cl_WL()
        plotter.output_Cl_phot()
        plotter.output_Cl_XC()
        plotter.output_GC_spectro()

    def process_chain(self):
        r"""Main method to obtain triangle plots

        Read the output key from the input dictionary and produce a triangle
        plot. For the moment, this function only works if Cobaya is specified
        as backend.

        Raises
        ------
        ValueError
           if the specified backend is not supported
        """

        parent_path = Path(__file__).resolve().parents[2]

        if self._backend == 'Cobaya':
            chain_path = parent_path / self._config[self._backend]['output']
            triangle_plot_cobaya(str(chain_path))

    def _get_model_path_from_cobaya_dict(self, cobaya_dict: dict):
        """Get the full model path from the Cobaya dictionary

        Returns the full path of the model file

        Parameters
        ----------
        cobaya_dict: dict
            the input cobaya dictionary

        Returns
        -------
        model_path: Path
            the full model path

        Raises
        ------
        ValueError
            if the value of the key 'param' in cobaya_dict
            is not a string
        """

        model_file = cobaya_dict['params']
        if type(model_file) is not str:
            raise ValueError('key \'params\' in the input yaml configuration '
                             'must be a string, the model yaml file path')

        return self._config_path.parents[0].joinpath(model_file)

    @staticmethod
    def _get_and_check_backend(config: dict):
        """Get and check the backend key

        Returns the value of the keyword 'backend'
        from the input configuration dictionary.

        Parameters
        ----------
        config: dict
            the input configuration dictionary

        Returns
        -------
        backend: str
            the specified backend

        Raises
        ------
        NotImplementedError
            if the specified backend is 'Cosmosis'
        ValueError
            if the specified backend is not supported
        """
        backend = config['backend']
        if backend == 'Cobaya':
            return backend
        elif backend == 'Cosmosis':
            raise NotImplementedError('Support for the Cosmosis backend is'
                                      ' not yet implemented')
        else:
            raise ValueError(f'The requested backend is not supported: '
                             f'{backend}')

    @staticmethod
    def _update_config(orig_config, update_config):
        r"""Update nested dictionary recursively

        Parameters
        ----------
        orig_config: dict
           The dictionary to be updated
        update_config: dict or Mapping
           The dictionary with the updates to be applied

        Returns
        -------
        dict
           The updated dict
        """
        for key, val in update_config.items():
            if isinstance(val, collections.abc.Mapping):
                orig_config[key] = (
                    LikelihoodUI._update_config(orig_config.get(key, {}), val)
                )
            else:
                orig_config[key] = val
        return orig_config
