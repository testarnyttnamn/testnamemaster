<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="17" failures="0" skipped="0" tests="313" time="341.999" timestamp="2023-11-07T20:20:57.859238" hostname="feynmannode09.cluster.local"><testcase classname="cloe.spectroscopic_survey.spectro" name="PYDOCSTYLE" time="0.038" /><testcase classname="cloe.spectroscopic_survey.spectro" name="PYCODESTYLE" time="0.052" /><testcase classname="cloe.cobaya_interface" name="PYDOCSTYLE" time="0.075" /><testcase classname="cloe.cobaya_interface" name="PYCODESTYLE" time="0.129" /><testcase classname="cloe.tests.test_spectro" name="PYCODESTYLE" time="0.052" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_f_out" time="0.345" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_f_out_z_dep" time="0.112" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_f_out_z_exception" time="0.117" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_gal_redshift_scatter" time="0.001" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_get_k" time="0.001" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_get_mu" time="0.001" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_multipole_correlation_function" time="0.024" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_multipole_spectra_integrand" time="0.112" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_multipole_spectra_m0" time="0.112" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_multipole_spectra_m1" time="0.270" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_multipole_spectra_m100" time="0.107" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_multipole_spectra_m2" time="0.110" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_multipole_spectra_m3" time="0.114" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_multipole_spectra_m4" time="0.116" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_scaling_factor_parall" time="0.001" /><testcase classname="cloe.tests.test_spectro.specinitTestCase" name="test_scaling_factor_perp" time="0.001" /><testcase classname="cloe.tests.test_nonlinear" name="PYCODESTYLE" time="0.096" /><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_Pdeltai_def" time="11.358"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_Pgdelta_phot_def" time="0.001"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_Pgdelta_spectro_def" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_Pgg_phot_def" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_Pgg_spectro_def" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_Pgi_phot_def" time="0.001"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_Pgi_spectro_def" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_Pii_def" time="0.001"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_extrapolation_Pmm_phot_def" time="0.002"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_extrapolation_options" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_fia" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_fia_k_array" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_fia_z_array" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_fia_zk_array" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_istf_phot_galbias" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_istf_spectro_galbias" time="0.000"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_nonlinear.nonlinearinitTestCase" name="test_noise_Pgg_spectro" time="0.001"><error message="failed on setup with &quot;AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]&quot;">cls = &lt;class 'cloe.tests.test_nonlinear.nonlinearinitTestCase'&gt;

    @classmethod
    def setUpClass(cls) -&gt; None:
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_1 = load_test_pickle('cosmo_test_NLphot1_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl1 = Nonlinear(cosmo_dic_1)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=1
        cosmo_dic_2 = load_test_pickle('cosmo_test_NLphot2_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl2 = Nonlinear(cosmo_dic_2)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=3
        cosmo_dic_3 = load_test_pickle('cosmo_test_NLphot3_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl3 = Nonlinear(cosmo_dic_3)
    
        # Load cosmology dictionary for tests with NL_flag_phot_matter=4
        cosmo_dic_4 = load_test_pickle('cosmo_test_NLphot4_dic.pickle')
        # Create instance of Nonlinear class
        cls.nl4 = Nonlinear(cosmo_dic_4)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_5 = cosmo_dic_3.copy()
        cosmo_dic_5['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5 = Nonlinear(cosmo_dic_5)
        cls.nl5.set_Pgg_spectro_model()
        cls.nl5.update_dic(cosmo_dic_5)
    
        # Copy cosmo_dic from NL_flag_phot_matter=3 (to have HMcode)
        cosmo_dic_6 = cosmo_dic_3.copy()
        cosmo_dic_6['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6 = Nonlinear(cosmo_dic_6)
        cls.nl6.set_Pgg_spectro_model()
        cls.nl6.update_dic(cosmo_dic_6)
    
        # Load cosmology dictionary for cosmology extrapolation tests
        cosmo_dic_extra = \
            load_test_pickle('cosmo_test_NLphot3_extra_dic.pickle')
        cosmo_dic_extra['NL_flag_phot_matter'] = 5
        # Create instance of Nonlinear class and update its dictionary
        cls.nl5_extra = Nonlinear(cosmo_dic_extra)
        cls.nl5_extra.set_Pgg_spectro_model()
        cls.nl5_extra.update_dic(cosmo_dic_extra)
    
        cosmo_dic_extra['NL_flag_phot_matter'] = 6
        # Create instance of Nonlinear class and update its dictionary
        cls.nl6_extra = Nonlinear(cosmo_dic_extra)
        cls.nl6_extra.set_Pgg_spectro_model()
&gt;       cls.nl6_extra.update_dic(cosmo_dic_extra)

cloe/tests/test_nonlinear.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cloe/non_linear/nonlinear.py:150: in update_dic
    self.calculate_boost()
cloe/non_linear/nonlinear.py:206: in calculate_boost
    wavenumber, boost, redshift_max, flag_range = self.bacco_boost()
cloe/non_linear/nonlinear.py:386: in bacco_boost
    self.bemu.get_nonlinear_boost(cold=False, **params)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:379: in get_nonlinear_boost
    value = self._evaluate_nonlinear(**kwargs)
/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:227: in _evaluate_nonlinear
    coords, pp, grid = self._get_parameters(kwargs, 'nonlinear')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;baccoemu.matter_powerspectrum.Matter_powerspectrum object at 0x7fff90c5a8f0&gt;
coordinates = {'A_s': array([None], dtype=object), 'cold': array([False]), 'expfactor': array([1.]), 'hubble': array([0.85]), ...}, which_emu = 'nonlinear'

    def _get_parameters(self, coordinates, which_emu):
        """
        Function that returns a dictionary of cosmological parameters,
        computing derived cosmological parameters, if not
        already present in the given coordinates, and checking the relevant boundaries.
        :param coordinates: a set of coordinates in parameter space
        :type coordinates: dict
        :param which_emu: kind of emulator: options are 'linear', 'nonlinear','baryon','smeared_bao','sigma8'
        :type which_emu: str
        :return: coordinates with derived parameters
        :rtype: dict
        """
        coordinates = {key: np.atleast_1d(coordinates[key]) for key in set(list(coordinates.keys())) - set(['k', 'k_lin', 'pk_lin'])}
    
        avail_pars = [coo for coo in coordinates.keys() if coordinates[coo][0] is not None] #parameters currently available
        eva_pars = self.emulator[which_emu]['keys']  #parameters strictly needed to evaluate the emulator
        req_pars = self.emulator[which_emu]['keys'] if which_emu != 'linear' else self.emulator[which_emu]['full_keys'] #parameters needed for a computation
        comp_pars = list(set(req_pars)-set(avail_pars)) #parameters to be computed
        deriv_pars = ['omega_cold','sigma8_cold', 'A_s'] #derived parameters that can be computed
        miss_pars = list(set(comp_pars)-set(deriv_pars)) #parameters missing from coordinates
        extra_pars = list(set(req_pars)-set(eva_pars)) #requested parameters not needed for evaluation
        if miss_pars:
            print(f"{which_emu} emulator:")
            print(f"  Please add the parameter(s) {miss_pars} to your coordinates!")
            raise KeyError(f"{which_emu} emulator: coordinates need the following parameters: ", miss_pars)
    
        if ('omega_cold' in avail_pars) &amp; ('omega_matter' in avail_pars):
            assert len(coordinates['omega_cold']) == len(coordinates['omega_matter']), 'Both omega_cold and omega_matter were provided, but they have different len'
            om_from_oc = coordinates['omega_cold'] + coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            assert np.all(np.abs(coordinates['omega_matter'] - om_from_oc) &lt; 1e-4), 'Both omega_cold and omega_matter were provided, but they are inconsistent among each other'
    
        if 'omega_cold' in comp_pars:
            if 'omega_matter' not in avail_pars:
                raise KeyError('One parameter between omega_matter and omega_cold must be provided!')
    
            omega_nu = coordinates['neutrino_mass'] / 93.14 /coordinates['hubble']**2
            coordinates['omega_cold'] = coordinates['omega_matter'] - omega_nu
    
        if ('sigma8_cold' not in avail_pars) &amp; ('A_s' not in avail_pars):
            raise KeyError('One parameter between sigma8_cold and A_s must be provided!')
    
        if ('sigma8_cold' in  avail_pars) &amp; ('A_s' in avail_pars):
            #commented for the cases where one is computed and same value is repeated
            #assert len(np.atleast_1d(coordinates['sigma8_cold'])) == len(atleast_1d(coordinates['A_s'])), 'Both sigma8_cold and A_s were provided, but they have different len'
    
            ignore_s8_pars = copy.deepcopy(coordinates)
            del ignore_s8_pars['sigma8_cold']
            ignore_s8_pars['cold'] = True
            s8_from_A_s = self.get_sigma8(**ignore_s8_pars)
            assert np.all(np.abs(coordinates['sigma8_cold'] - s8_from_A_s) &lt; 1e-4), 'Both sigma8_cold and A_s were provided, but they are inconsistent among each other'
    
        if 'sigma8_cold' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            tmp_coords['cold']=True
            coordinates['sigma8_cold'] = np.atleast_1d(self.get_sigma8(**tmp_coords))
    
        if 'A_s' in comp_pars:
            tmp_coords = copy.deepcopy(coordinates)
            del tmp_coords['sigma8_cold']
            tmp_coords['A_s'] = 2e-9
            tmp_coords['cold'] = True
            coordinates['A_s'] = np.atleast_1d((coordinates['sigma8_cold'] / self.get_sigma8(**tmp_coords))**2 * tmp_coords['A_s'])
    
        pp = np.squeeze([coordinates[p][0] for p in eva_pars])
        coords_out = copy.deepcopy(coordinates)
    
        grid = {}
        for key in coordinates.keys():
            if len(np.atleast_1d(coordinates[key])) &gt; 1:
                grid[key] = np.array(coordinates[key])
    
        if len(list(grid.keys()))==0:
            grid = None
        else:
            grid_structure = []
            for key in grid.keys():
                grid_structure.append(len(grid[key]))
            grid_structure = np.array(grid_structure)
            values, counts = np.unique(grid_structure, return_counts=True)
            counts_but_highest = np.delete(counts, np.argmax(counts))
            assert np.all(counts == counts[0]) | np.all(counts_but_highest == 1), 'When passing multiple coordinate sets you should either vary only on parameter, or all parameters should have the same len'
    
        if grid is not None:
            grid_pars = list(grid.keys()) # list of parameters that are varyied in a grid
            N = len(grid[grid_pars[0]])
            pp = np.tile(pp, (N, 1))
            for par in grid_pars:
                if par in eva_pars:
                    index = eva_pars.index(par)
                    pp[:,index] = np.float64(grid[par])
                if par in req_pars:
                    coords_out[par] = grid[par]
            pp = np.float64(pp)
    
        for i,par in enumerate(eva_pars):
            val = pp[i] if grid is None else pp[:,i]
            message = 'Param {}={} out of bounds [{}, {}]'.format(
                par, val, self.emulator[which_emu]['bounds'][i][0], self.emulator[which_emu]['bounds'][i][1])
    
&gt;           assert np.all(val &gt;= self.emulator[which_emu]['bounds'][i][0]) &amp; np.all(val &lt;= self.emulator[which_emu]['bounds'][i][1]), message
E           AssertionError: Param omega_cold=0.2160899653979239 out of bounds [0.23, 0.4]

/feynman/home/dap/lcs/lg268561/.conda/envs/my_env/lib/python3.10/site-packages/baccoemu/matter_powerspectrum.py:184: AssertionError</error></testcase><testcase classname="cloe.tests.test_like_calc" name="PYCODESTYLE" time="0.032" /><testcase classname="cloe.tests.test_like_calc.likecalcTestCase" name="test_loglike" time="70.657" /><testcase classname="cloe.tests.test_like_calc.likecalcBNT_TestCase" name="test_loglike_BNT_unity" time="66.690" /><testcase classname="cloe.tests.test_like_calc.likecalcngTestCase" name="test_loglike_ng" time="67.617" /><testcase classname="cloe.tests.test_like_calc.likecalcngTestCase" name="test_spectro_cov_nsim" time="11.298" /><testcase classname="cloe.cosmo.cosmology" name="PYDOCSTYLE" time="0.096" /><testcase classname="cloe.cosmo.cosmology" name="PYCODESTYLE" time="0.139" /><testcase classname="cloe.tests.test_tools.spectro_test_handler" name="PYDOCSTYLE" time="0.007" /><testcase classname="cloe.tests.test_tools.spectro_test_handler" name="PYCODESTYLE" time="0.006" /><testcase classname="cloe.tests.test_eft" name="PYCODESTYLE" time="0.066" /><testcase classname="cloe.tests.test_eft.eftinitTestCase" name="test_CallEH_NW" time="0.062" /><testcase classname="cloe.tests.test_eft.eftinitTestCase" name="test_IRresum" time="0.004" /><testcase classname="cloe.tests.test_eft.eftinitTestCase" name="test_P_kmu_z" time="0.044" /><testcase classname="cloe.tests.test_eft.eftinitTestCase" name="test_Pgg_kmu_terms" time="0.029" /><testcase classname="cloe.tests.test_eft.eftinitTestCase" name="test_gaussianFiltering" time="0.002" /><testcase classname="cloe.tests.test_eft.eftinitTestCase" name="test_muxdamp" time="0.001" /><testcase classname="cloe.auxiliary.redshift_bins" name="PYDOCSTYLE" time="0.018" /><testcase classname="cloe.auxiliary.redshift_bins" name="PYCODESTYLE" time="0.021" /><testcase classname="cloe.non_linear.eft" name="PYDOCSTYLE" time="0.083" /><testcase classname="cloe.non_linear.eft" name="PYCODESTYLE" time="0.126" /><testcase classname="cloe.non_linear.nonlinear" name="PYDOCSTYLE" time="0.056" /><testcase classname="cloe.non_linear.nonlinear" name="PYCODESTYLE" time="0.085" /><testcase classname="cloe.non_linear.pgg_spectro" name="PYDOCSTYLE" time="0.012" /><testcase classname="cloe.non_linear.pgg_spectro" name="PYCODESTYLE" time="0.013" /><testcase classname="cloe.tests.test_cosmo" name="PYCODESTYLE" time="0.073" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_MG_mu" time="0.011" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_MG_mu_def" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_MG_sigma" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_MG_sigma_def" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pdeltai" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgdelta_phot" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgdelta_phot_interp" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgdelta_spectro" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgdelta_spectro_interp" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgg_phot" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgg_phot_interp" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgg_spectro" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgg_spectro_interp" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgi_phot" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pgi_spectro" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_Pii" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_compute_phot_galbias" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_cosmo_asign" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_cosmo_growth_factor" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_cosmo_growth_factor_interp" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_cosmo_growth_rate" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_cosmo_growth_rate_MG_interp" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_cosmo_growth_rate_interp" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_cosmo_init" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_cosmo_nuisance_init" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_growth_factor_MG" time="0.019" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_growth_rate_MG" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_istf_spectro_galbias" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_matter_density" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_pk_source" time="0.000" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_poly_phot_galbias" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_rescaled_halomodel_power_MG" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_rescaled_linear_power_MG" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_rescaled_linear_power_cb_MG" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_transverse_comoving_dist" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_transverse_comoving_dist_z12" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_transverse_comoving_dist_z12_curv_neg" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_transverse_comoving_dist_z12_curv_pos" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_update_cosmo_dic" time="0.134" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_z_of_r_inverse" time="0.001" /><testcase classname="cloe.tests.test_cosmo.cosmoinitTestCase" name="test_z_win_exception" time="0.001" /><testcase classname="cloe.tests.test_tools.cobaya_model_handler" name="PYDOCSTYLE" time="0.018" /><testcase classname="cloe.tests.test_tools.cobaya_model_handler" name="PYCODESTYLE" time="0.024" /><testcase classname="cloe.non_linear.miscellanous" name="PYDOCSTYLE" time="0.012" /><testcase classname="cloe.non_linear.miscellanous" name="PYCODESTYLE" time="0.013" /><testcase classname="cloe.tests.test_input.data" name="PYDOCSTYLE" time="0.005" /><testcase classname="cloe.tests.test_input.data" name="PYCODESTYLE" time="0.005" /><testcase classname="cloe.tests.test_input.mock_observables" name="PYDOCSTYLE" time="0.009" /><testcase classname="cloe.tests.test_input.mock_observables" name="PYCODESTYLE" time="0.013" /><testcase classname="cloe.tests.test_input.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.tests.test_input.__init__" name="PYCODESTYLE" time="0.002" /><testcase classname="cloe.tests.test_input.base_test_cosmo" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.tests.test_input.base_test_cosmo" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.photometric_survey.photo" name="PYDOCSTYLE" time="0.088" /><testcase classname="cloe.photometric_survey.photo" name="PYCODESTYLE" time="0.132" /><testcase classname="cloe.like_calc.euclike" name="PYDOCSTYLE" time="0.055" /><testcase classname="cloe.like_calc.euclike" name="PYCODESTYLE" time="0.093" /><testcase classname="cloe.data_reader.reader" name="PYDOCSTYLE" time="0.046" /><testcase classname="cloe.data_reader.reader" name="PYCODESTYLE" time="0.071" /><testcase classname="cloe.user_interface.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.user_interface.__init__" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.user_interface.likelihood_ui" name="PYDOCSTYLE" time="0.701" /><testcase classname="cloe.user_interface.likelihood_ui" name="PYCODESTYLE" time="0.038" /><testcase classname="cloe.tests.test_yaml_handler" name="PYCODESTYLE" time="0.012" /><testcase classname="cloe.tests.test_yaml_handler.yaml_handler_test" name="test_read" time="0.002" /><testcase classname="cloe.tests.test_yaml_handler.yaml_handler_test" name="test_read_and_check_dict" time="0.001" /><testcase classname="cloe.tests.test_yaml_handler.yaml_handler_test" name="test_read_and_check_dict_bad_dict" time="0.001" /><testcase classname="cloe.tests.test_yaml_handler.yaml_handler_test" name="test_read_and_check_dict_bad_type" time="0.001" /><testcase classname="cloe.tests.test_yaml_handler.yaml_handler_test" name="test_write" time="0.001" /><testcase classname="cloe.tests.test_yaml_handler.yaml_handler_test" name="test_write_bad_input_type" time="0.000" /><testcase classname="cloe.tests.test_yaml_handler.yaml_handler_test" name="test_write_overwrite_exception" time="0.001" /><testcase classname="cloe.tests.test_tools.test_data_handler" name="PYCODESTYLE" time="0.009" /><testcase classname="cloe.tests.test_tools.mock_objects" name="PYDOCSTYLE" time="0.007" /><testcase classname="cloe.tests.test_tools.mock_objects" name="PYCODESTYLE" time="0.007" /><testcase classname="cloe.tests.test_tools.__init__" name="PYDOCSTYLE" time="0.002" /><testcase classname="cloe.tests.test_tools.__init__" name="PYCODESTYLE" time="0.002" /><testcase classname="cloe.tests.test_redshift_bins" name="PYCODESTYLE" time="0.026" /><testcase classname="cloe.tests.test_redshift_bins.RedshiftBinsTestCase" name="test_coerce_scalar" time="0.001" /><testcase classname="cloe.tests.test_redshift_bins.RedshiftBinsTestCase" name="test_coerce_vector" time="0.001" /><testcase classname="cloe.tests.test_redshift_bins.RedshiftBinsTestCase" name="test_compute_means_of_consecutive" time="0.001" /><testcase classname="cloe.tests.test_redshift_bins.RedshiftBinsTestCase" name="test_find_bin_scalar" time="0.001" /><testcase classname="cloe.tests.test_redshift_bins.RedshiftBinsTestCase" name="test_find_indices_vector" time="0.001" /><testcase classname="cloe.tests.test_redshift_bins.RedshiftBinsTestCase" name="test_reduce" time="0.001" /><testcase classname="cloe.tests.test_redshift_distribution" name="PYCODESTYLE" time="0.019" /><testcase classname="cloe.tests.test_redshift_distribution.RedshiftDistributionTestCase" name="test_evaluates_n_i_z_only_shift" time="0.004" /><testcase classname="cloe.tests.test_redshift_distribution.RedshiftDistributionTestCase" name="test_evaluates_n_i_z_zero_shift" time="0.003" /><testcase classname="cloe.tests.test_redshift_distribution.RedshiftDistributionTestCase" name="test_init_bad_nuisance_dict" time="0.003" /><testcase classname="cloe.tests.test_redshift_distribution.RedshiftDistributionTestCase" name="test_init_success" time="0.003" /><testcase classname="cloe.tests.test_redshift_distribution.RedshiftDistributionTestCase" name="test_interpolates_n_i_z_only_shift" time="0.004" /><testcase classname="cloe.tests.test_test_tools" name="PYCODESTYLE" time="0.012" /><testcase classname="cloe.tests.test_test_tools.TestDataHandlerTestCase" name="test_load_test_npy" time="0.002" /><testcase classname="cloe.tests.test_test_tools.TestDataHandlerTestCase" name="test_load_test_pickle" time="0.001" /><testcase classname="cloe.tests.test_test_tools.TestDataHandlerTestCase" name="test_save_test_pickle" time="0.001" /><testcase classname="cloe.tests.test_params_converter" name="PYCODESTYLE" time="0.007" /><testcase classname="cloe.tests.test_params_converter.ParamsConverterTestCase" name="test_camb_to_classy_conversion" time="0.001" /><testcase classname="cloe.tests.test_params_converter.ParamsConverterTestCase" name="test_classy_to_camb_conversion" time="0.001" /><testcase classname="cloe.tests.test_phot" name="PYCODESTYLE" time="0.088" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_Cl_GC_phot_precomputed" time="3.606" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_Cl_WL_precomputed" time="0.009" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_Cl_cross_precomputed" time="0.009" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_GC_window" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_GC_window_RSD" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_IA_window" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_WL_window" time="0.060" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_WL_window_slow" time="0.004" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_cl_GC" time="0.004" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_cl_GC_RSD" time="0.004" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_cl_WL" time="0.004" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_cl_cross" time="0.004" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_cl_cross_RSD" time="0.004" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_corr_func_invalid_obs" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_corr_func_invalid_type" time="0.000" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_corr_func_pp" time="0.056" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_corr_func_sp" time="0.060" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_corr_func_ssm" time="0.053" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_corr_func_ssp" time="0.081" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_eval_prefactor_l_0" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_eval_prefactor_l_minus1" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_eval_prefactor_l_plus1" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_eval_prefactor_mag" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_eval_prefactor_shearia" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_f_K_z_func_is_None" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_magnification_window" time="0.061" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_magnification_window_1" time="0.062" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_poly_mag_bias" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_power_exception" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_set_prefactor" time="0.005" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_unpack_RSD_kernel" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_w_integrand" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_z_minus1" time="0.001" /><testcase classname="cloe.tests.test_phot.photoinitTestCase" name="test_z_plus1" time="0.001" /><testcase classname="cloe.tests.test_matrix_manipulator" name="PYCODESTYLE" time="0.010" /><testcase classname="cloe.tests.test_matrix_manipulator.MatrixManipulator_test" name="test_merge_matrices" time="0.001" /><testcase classname="cloe.tests.test_likelihood_yaml_handler" name="PYCODESTYLE" time="0.019" /><testcase classname="cloe.tests.test_likelihood_yaml_handler.yaml_handler_test" name="test_generate_params_dict_from_model_dict" time="0.002" /><testcase classname="cloe.tests.test_likelihood_yaml_handler.yaml_handler_test" name="test_generate_params_dict_from_model_dict_nocosmo" time="0.001" /><testcase classname="cloe.tests.test_likelihood_yaml_handler.yaml_handler_test" name="test_get_params_dict_without_cosmo_params" time="0.001" /><testcase classname="cloe.tests.test_likelihood_yaml_handler.yaml_handler_test" name="test_load_model_dict_from_yaml" time="0.001" /><testcase classname="cloe.tests.test_likelihood_yaml_handler.yaml_handler_test" name="test_update_cobaya_params_from_model_yaml" time="0.001" /><testcase classname="cloe.tests.test_likelihood_yaml_handler.yaml_handler_test" name="test_update_cobaya_params_from_model_yaml_overwrite" time="0.002" /><testcase classname="cloe.tests.test_likelihood_yaml_handler.yaml_handler_test" name="test_write_params_yaml_from_model_dict" time="0.002" /><testcase classname="cloe.tests.test_masking" name="PYCODESTYLE" time="0.027" /><testcase classname="cloe.tests.test_masking.Masking_test" name="test_get_masked_covariance_matrix" time="0.001" /><testcase classname="cloe.tests.test_masking.Masking_test" name="test_get_masked_data_vector" time="0.001" /><testcase classname="cloe.tests.test_masking.Masking_test" name="test_get_masked_theory_vector" time="0.001" /><testcase classname="cloe.tests.test_masking.Masking_test" name="test_set_covariance_matrix" time="0.001" /><testcase classname="cloe.tests.test_masking.Masking_test" name="test_set_covariance_matrix_invalid" time="0.001" /><testcase classname="cloe.tests.test_masking.Masking_test" name="test_set_data_vector" time="0.001" /><testcase classname="cloe.tests.test_masking.Masking_test" name="test_set_masking_vector" time="0.001" /><testcase classname="cloe.tests.test_masking.Masking_test" name="test_set_theory_vector" time="0.001" /><testcase classname="cloe.spectroscopic_survey.__init__" name="PYDOCSTYLE" time="0.004" /><testcase classname="cloe.spectroscopic_survey.__init__" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.tests.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.tests.__init__" name="PYCODESTYLE" time="0.002" /><testcase classname="cloe.tests.test_aux" name="PYCODESTYLE" time="0.016" /><testcase classname="cloe.tests.test_aux.plotterTestCase" name="test_ext_GC_spectro_multipole_excep" time="1.384" /><testcase classname="cloe.tests.test_aux.plotterTestCase" name="test_ext_XC_phot_excep" time="0.001" /><testcase classname="cloe.tests.test_aux.plotterTestCase" name="test_ext_phot_excep" time="0.001" /><testcase classname="cloe.tests.test_aux.plotterTestCase" name="test_plot_GC_spectro_multipole_excep" time="0.001" /><testcase classname="cloe.tests.test_aux.plotterTestCase" name="test_plot_XC_phot_excep" time="0.001" /><testcase classname="cloe.tests.test_aux.plotterTestCase" name="test_plot_phot_excep" time="0.001" /><testcase classname="cloe.tests.test_aux.plotterTestCase" name="test_plotter_init" time="0.001" /><testcase classname="cloe.tests.test_data_handler" name="PYCODESTYLE" time="0.030" /><testcase classname="cloe.tests.test_data_handler.datahandlerTestCase" name="test_create_cov_matrix" time="0.966" /><testcase classname="cloe.tests.test_data_handler.datahandlerTestCase" name="test_create_data_vector" time="0.001" /><testcase classname="cloe.tests.test_data_handler.datahandlerTestCase" name="test_create_masking_vectors" time="0.004" /><testcase classname="cloe.tests.test_data_handler.datahandlerTestCase" name="test_observables_selection" time="0.003" /><testcase classname="cloe.tests.test_data_handler.datahandlerTestCase" name="test_spectro_data_size" time="0.001" /><testcase classname="cloe.tests.test_data_reader" name="PYCODESTYLE" time="0.049" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_bench_gc_cov_check" time="0.107" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_bench_phot_cls_check" time="0.156" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_bench_phot_cov_check" time="0.212" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_data_dict_init" time="0.072" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_fiducial_reading_check" time="0.110" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_gc_fname_exception" time="0.072" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_gc_spec_cov_num_check_cov_nsim_exists" time="0.071" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_gc_spec_cov_num_check_cov_nsim_is_number" time="0.071" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_gc_spec_cov_num_check_cov_nsim_is_positive" time="0.070" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_nz_GC_Phot_dict_init" time="0.070" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_nz_GC_Phot_dict_interpolator" time="0.070" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_nz_WL_dict_init" time="0.070" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_nz_WL_dict_interpolator" time="0.070" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_phot_cov_num_check_cov_nsim_exists" time="0.070" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_phot_cov_num_check_cov_nsim_is_number" time="0.070" /><testcase classname="cloe.tests.test_data_reader.datareaderTestCase" name="test_photo_cov_num_check_cov_nsim_is_positive" time="0.071" /><testcase classname="cloe.tests.test_fftlog" name="PYCODESTYLE" time="0.011" /><testcase classname="cloe.tests.test_fftlog.fftloginitTestCase" name="test_hankel" time="0.003" /><testcase classname="cloe.photometric_survey.redshift_distribution" name="PYDOCSTYLE" time="0.011" /><testcase classname="cloe.photometric_survey.redshift_distribution" name="PYCODESTYLE" time="0.010" /><testcase classname="cloe.non_linear.pLL_phot" name="PYDOCSTYLE" time="0.021" /><testcase classname="cloe.non_linear.pLL_phot" name="PYCODESTYLE" time="0.024" /><testcase classname="cloe.non_linear.pgL_phot" name="PYDOCSTYLE" time="0.007" /><testcase classname="cloe.non_linear.pgL_phot" name="PYCODESTYLE" time="0.014" /><testcase classname="cloe.non_linear.pgg_phot" name="PYDOCSTYLE" time="0.007" /><testcase classname="cloe.non_linear.pgg_phot" name="PYCODESTYLE" time="0.008" /><testcase classname="cloe.non_linear.power_spectrum" name="PYDOCSTYLE" time="0.005" /><testcase classname="cloe.non_linear.power_spectrum" name="PYCODESTYLE" time="0.005" /><testcase classname="cloe.photometric_survey.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.photometric_survey.__init__" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.non_linear.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.non_linear.__init__" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.masking.data_handler" name="PYDOCSTYLE" time="0.048" /><testcase classname="cloe.masking.data_handler" name="PYCODESTYLE" time="0.071" /><testcase classname="cloe.masking.masking" name="PYDOCSTYLE" time="0.014" /><testcase classname="cloe.masking.masking" name="PYCODESTYLE" time="0.016" /><testcase classname="cloe.masking.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.masking.__init__" name="PYCODESTYLE" time="0.022" /><testcase classname="cloe.like_calc.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.like_calc.__init__" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.info" name="PYDOCSTYLE" time="0.004" /><testcase classname="cloe.info" name="PYCODESTYLE" time="0.005" /><testcase classname="cloe.fftlog.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.fftlog.__init__" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.fftlog.fftlog" name="PYDOCSTYLE" time="0.016" /><testcase classname="cloe.fftlog.fftlog" name="PYCODESTYLE" time="0.016" /><testcase classname="cloe.fftlog.hankel" name="PYDOCSTYLE" time="0.006" /><testcase classname="cloe.fftlog.hankel" name="PYCODESTYLE" time="0.007" /><testcase classname="cloe.fftlog.utils" name="PYDOCSTYLE" time="0.014" /><testcase classname="cloe.fftlog.utils" name="PYCODESTYLE" time="0.018" /><testcase classname="cloe.data_reader.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.data_reader.__init__" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.cosmo.__init__" name="PYDOCSTYLE" time="0.005" /><testcase classname="cloe.cosmo.__init__" name="PYCODESTYLE" time="0.006" /><testcase classname="cloe.auxiliary.yaml_handler" name="PYDOCSTYLE" time="0.008" /><testcase classname="cloe.auxiliary.yaml_handler" name="PYCODESTYLE" time="0.009" /><testcase classname="cloe.auxiliary.run_method" name="PYDOCSTYLE" time="0.004" /><testcase classname="cloe.auxiliary.run_method" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.auxiliary.likelihood_yaml_handler" name="PYDOCSTYLE" time="0.022" /><testcase classname="cloe.auxiliary.likelihood_yaml_handler" name="PYCODESTYLE" time="0.029" /><testcase classname="cloe.auxiliary.logger" name="PYDOCSTYLE" time="0.014" /><testcase classname="cloe.auxiliary.logger" name="PYCODESTYLE" time="0.017" /><testcase classname="cloe.auxiliary.matrix_manipulator" name="PYDOCSTYLE" time="0.005" /><testcase classname="cloe.auxiliary.matrix_manipulator" name="PYCODESTYLE" time="0.005" /><testcase classname="cloe.auxiliary.matrix_transforms" name="PYDOCSTYLE" time="0.018" /><testcase classname="cloe.auxiliary.matrix_transforms" name="PYCODESTYLE" time="0.023" /><testcase classname="cloe.auxiliary.observables_dealer" name="PYDOCSTYLE" time="0.012" /><testcase classname="cloe.auxiliary.observables_dealer" name="PYCODESTYLE" time="0.017" /><testcase classname="cloe.auxiliary.params_converter" name="PYDOCSTYLE" time="0.011" /><testcase classname="cloe.auxiliary.params_converter" name="PYCODESTYLE" time="0.014" /><testcase classname="cloe.auxiliary.plotter" name="PYDOCSTYLE" time="0.052" /><testcase classname="cloe.auxiliary.plotter" name="PYCODESTYLE" time="0.082" /><testcase classname="cloe.auxiliary.plotter_default" name="PYDOCSTYLE" time="0.005" /><testcase classname="cloe.auxiliary.plotter_default" name="PYCODESTYLE" time="0.005" /><testcase classname="cloe.auxiliary.__init__" name="PYDOCSTYLE" time="0.006" /><testcase classname="cloe.auxiliary.__init__" name="PYCODESTYLE" time="0.003" /><testcase classname="cloe.auxiliary.getdist_routines" name="PYDOCSTYLE" time="0.006" /><testcase classname="cloe.auxiliary.getdist_routines" name="PYCODESTYLE" time="0.007" /><testcase classname="cloe.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="cloe.__init__" name="PYCODESTYLE" time="0.003" /></testsuite></testsuites>